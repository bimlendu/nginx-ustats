Only in ../nginx-0.8.53-dev/src/core: .svn
Only in ../nginx-0.8.53-dev/src/event/modules: .svn
Only in ../nginx-0.8.53-dev/src/event: .svn
Only in ../nginx-0.8.53-dev/src/http/modules/perl: .svn
Only in ../nginx-0.8.53-dev/src/http/modules: .svn
Only in ../nginx-0.8.53-dev/src/http/modules: ustats
diff -cr src/http/ngx_http.h ../nginx-0.8.53-dev/src/http/ngx_http.h
*** src/http/ngx_http.h	2011-02-08 10:39:27.029866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http.h	2011-02-08 09:56:13.779866000 +0500
***************
*** 156,159 ****
--- 156,193 ----
  extern ngx_http_output_body_filter_pt    ngx_http_top_body_filter;
  
  
+ #if (NGX_HAVE_USTATS_MODULE)
+ /// Number of counters for each peer
+ #define USTATS_PEER_STATS_COUNT           8
+  
+ /// Stat offset relative to the peer position within the shared memory
+ #define USTATS_REQ_STAT_INDEX             0
+  
+ /// Holds HTTP 499 errors count
+ #define USTATS_HTTP499_STAT_INDEX         1
+  
+ /// Holds HTTP 500 errors count
+ #define USTATS_HTTP500_STAT_INDEX         2
+  
+ /// Holds HTTP 503 errors count
+ #define USTATS_HTTP503_STAT_INDEX         3
+  
+ /// Holds TCP errors count
+ #define USTATS_TCP_ERR_STAT_INDEX         4
+  
+ /// Holds read timeouts count
+ #define USTATS_READ_TIMEOUT_STAT_INDEX    5
+  
+ /// Holds write timeouts count
+ #define USTATS_WRITE_TIMEOUT_STAT_INDEX   6
+  
+ /// Holds last failed access time across all workers
+ #define USTATS_BLACKLISTED_STAT_INDEX     7
+  
+ /// Shared memory for storing counters. Defined in ngx_http_ustats_module.c
+ extern ngx_shm_zone_t * stats_data;
+ 
+ #endif
+ 
+ 
  #endif /* _NGX_HTTP_H_INCLUDED_ */
diff -cr src/http/ngx_http_upstream.c ../nginx-0.8.53-dev/src/http/ngx_http_upstream.c
*** src/http/ngx_http_upstream.c	2011-02-08 10:39:27.019866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http_upstream.c	2011-02-08 10:08:12.969866000 +0500
***************
*** 1106,1111 ****
--- 1106,1117 ----
  
      c = u->peer.connection;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     ngx_http_upstream_rr_peer_data_t  *rrp = u->peer.data;
+     ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+         rrp->peers->peer[rrp->current].shm_start_ind + USTATS_REQ_STAT_INDEX, 1);
+ #endif
+ 
      c->data = r;
  
      c->write->handler = ngx_http_upstream_handler;
***************
*** 1416,1421 ****
--- 1422,1432 ----
                     "http upstream send request handler");
  
      if (c->write->timedout) {
+ #if (NGX_HAVE_USTATS_MODULE)
+         ngx_http_upstream_rr_peer_data_t  *rrp = u->peer.data;
+         ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+             rrp->peers->peer[rrp->current].shm_start_ind + USTATS_WRITE_TIMEOUT_STAT_INDEX, 1);
+ #endif
          ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);
          return;
      }
***************
*** 1456,1461 ****
--- 1467,1477 ----
      c->log->action = "reading response header from upstream";
  
      if (c->read->timedout) {
+ #if (NGX_HAVE_USTATS_MODULE)
+         ngx_http_upstream_rr_peer_data_t  *rrp = u->peer.data;
+         ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+             rrp->peers->peer[rrp->current].shm_start_ind + USTATS_READ_TIMEOUT_STAT_INDEX, 1);
+ #endif
          ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);
          return;
      }
***************
*** 1636,1641 ****
--- 1652,1675 ----
  
      status = u->headers_in.status_n;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     ngx_http_upstream_rr_peer_data_t  *rrp = u->peer.data;
+     switch (status)
+     {
+         case 500:
+             ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+                 rrp->peers->peer[rrp->current].shm_start_ind + USTATS_HTTP500_STAT_INDEX, 1);
+             break;
+ 
+         case 503:
+             ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+                 rrp->peers->peer[rrp->current].shm_start_ind + USTATS_HTTP503_STAT_INDEX, 1);
+ 
+         default:
+             break;
+     }
+ #endif
+ 
      for (un = ngx_http_upstream_next_errors; un->status; un++) {
  
          if (status != un->status) {
***************
*** 2780,2785 ****
--- 2814,2826 ----
  {
      ngx_uint_t  status, state;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     ngx_http_upstream_rr_peer_data_t *rrp = u->peer.data;
+     if (rrp->peers->peer[rrp->current].fails + 1 >= rrp->peers->peer[rrp->current].max_fails
+         || rrp->peers->peer[rrp->current].max_fails == 1)
+         ((time_t*)stats_data->data)[rrp->peers->peer[rrp->current].shm_start_ind + USTATS_BLACKLISTED_STAT_INDEX] = ngx_time();
+ #endif
+ 
      ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                     "http next upstream, %xi", ft_type);
  
***************
*** 3020,3025 ****
--- 3061,3075 ----
          rc = ngx_http_send_special(r, NGX_HTTP_LAST);
      }
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     ngx_http_upstream_rr_peer_data_t *rrp = u->peer.data;
+     if (rc == NGX_HTTP_CLIENT_CLOSED_REQUEST)
+     {
+         ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data + 
+                 rrp->peers->peer[rrp->current].shm_start_ind + USTATS_HTTP499_STAT_INDEX, 1);
+     }
+ #endif
+ 
      ngx_http_finalize_request(r, rc);
  }
  
***************
*** 4074,4079 ****
--- 4124,4135 ----
      u.url = value[1];
      u.default_port = 80;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     us->name.data = ngx_pnalloc(cf->pool, (u.url.len + 1/* with '\0' ?*/) * sizeof(u_char));
+     us->name.len = u.url.len;
+     (void)ngx_cpymem(us->name.data, u.url.data, u.url.len + 1);
+ #endif
+ 
      if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
          if (u.err) {
              ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
diff -cr src/http/ngx_http_upstream.h ../nginx-0.8.53-dev/src/http/ngx_http_upstream.h
*** src/http/ngx_http_upstream.h	2011-02-08 10:39:27.019866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http_upstream.h	2011-02-08 10:29:41.519866001 +0500
***************
*** 89,94 ****
--- 89,98 ----
  
      unsigned                         down:1;
      unsigned                         backup:1;
+ 
+ #if (NGX_HAVE_USTATS_MODULE)
+     ngx_str_t                        name; // original name, unresolved
+ #endif
  } ngx_http_upstream_server_t;
  
  
diff -cr src/http/ngx_http_upstream_round_robin.c ../nginx-0.8.53-dev/src/http/ngx_http_upstream_round_robin.c
*** src/http/ngx_http_upstream_round_robin.c	2011-02-08 10:39:27.019866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http_upstream_round_robin.c	2011-02-08 10:33:53.969866001 +0500
***************
*** 8,13 ****
--- 8,17 ----
  #include <ngx_core.h>
  #include <ngx_http.h>
  
+ #if (NGX_HAVE_USTATS_MODULE)
+ static ngx_uint_t shm_peer_index = 0;
+ #endif
+ 
  
  static ngx_int_t ngx_http_upstream_cmp_servers(const void *one,
      const void *two);
***************
*** 65,70 ****
--- 69,79 ----
                  peers->peer[n].down = server[i].down;
                  peers->peer[n].weight = server[i].down ? 0 : server[i].weight;
                  peers->peer[n].current_weight = peers->peer[n].weight;
+ #if (NGX_HAVE_USTATS_MODULE)
+                 peers->peer[n].server = server + i;
+                 peers->peer[n].shm_start_ind = shm_peer_index;
+                 shm_peer_index += USTATS_PEER_STATS_COUNT;
+ #endif
                  n++;
              }
          }
***************
*** 118,123 ****
--- 127,137 ----
                  backup->peer[n].max_fails = server[i].max_fails;
                  backup->peer[n].fail_timeout = server[i].fail_timeout;
                  backup->peer[n].down = server[i].down;
+ #if (NGX_HAVE_USTATS_MODULE)
+                 peers->peer[n].server = server + i;
+                 peers->peer[n].shm_start_ind = shm_peer_index;
+                 shm_peer_index += USTATS_PEER_STATS_COUNT;
+ #endif
                  n++;
              }
          }
***************
*** 176,181 ****
--- 190,200 ----
          peers->peer[i].current_weight = 1;
          peers->peer[i].max_fails = 1;
          peers->peer[i].fail_timeout = 10;
+ #if (NGX_HAVE_USTATS_MODULE)
+         peers->peer[i].server = NULL;
+         peers->peer[i].shm_start_ind = shm_peer_index;
+         shm_peer_index += USTATS_PEER_STATS_COUNT;
+ #endif
      }
  
      us->peer.data = peers;
diff -cr src/http/ngx_http_upstream_round_robin.h ../nginx-0.8.53-dev/src/http/ngx_http_upstream_round_robin.h
*** src/http/ngx_http_upstream_round_robin.h	2011-02-08 10:39:27.019866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http_upstream_round_robin.h	2011-02-08 10:28:55.739866001 +0500
***************
*** 32,37 ****
--- 32,43 ----
  #if (NGX_HTTP_SSL)
      ngx_ssl_session_t              *ssl_session;   /* local to a process */
  #endif
+ 
+ #if (NGX_HAVE_USTATS_MODULE)
+     /* points to the server whose configuration was used for this peer */
+     ngx_http_upstream_server_t      *server;
+     ngx_uint_t                      shm_start_ind;
+ #endif
  } ngx_http_upstream_rr_peer_t;
  
  
Only in ../nginx-0.8.53-dev/src/http: .svn
Only in ../nginx-0.8.53-dev/src/mail: .svn
Only in ../nginx-0.8.53-dev/src/misc: .svn
Only in ../nginx-0.8.53-dev/src/os: .svn
Only in ../nginx-0.8.53-dev/src/os/unix: .svn
Only in ../nginx-0.8.53-dev/src: .svn
